---
title: "How to become a better R code detective?"
date: '2021-07-12'
tags:
  - package-development
  - debugging
  - reprex
slug: code-detective
output: hugodown::hugo_document
---

When trying to fix a bug or add a feature to a package, how do you go from viewing the code as a big messy ball of wool, to a logical diagram that you can bend to your will?
In this post, I will share some resources and tips on getting better at debugging and reading code, written by someone else or yourself long enough ago to feel foreign.

[keep track](https://wizardzines.com/comics/track-your-progress/)

After step 1, there's not really an order for the steps, but you definitely want to acquire enough knowledge through research before you tinker, otherwise you will be tinkering quite randomly.

Apart from the idea of adding tests, most tips could apply to non-package code.

## Step 0: Only deal with well-designed code

This is obviously not an actual tip, but more of a encouragement to try and write better and better code ourselves.

The [Tidyverse style guide](https://style.tidyverse.org/) is a good read, both for learning tips, and for seeing what aspects such a style guide applies to.
Of particular interest are e.g. the mention of [function comments](https://style.tidyverse.org/functions.html#comments-1), and [file organization](https://style.tidyverse.org/package-files.html#organisation-1).

Regarding code comments, I was intrigued and impressed by the notion of "explaining variables" mentioned in the tweet below referring a [great short post](https://blog.thepete.net/blog/2021/06/24/explaining-variable/).

`r hugodown::embed_tweet("1412140590842597385")`

Beyond its being well designed, it'll also help if the code is well tested: tests can help you understand the goals behind functions, and will help you re-factor without breaking features.

Now, we don't always choose what code we get, and even if it was well-designed, we might still need detective skills anyway!

## Step 1: Clone and build

In sharing this life-changing tip I am merely repeating the talk "Reading other people's code" by Patricia Aas that I actually listened to as [an episode of the All Things Git podcast](https://www.allthingsgit.com/episodes/learning_a_new_codebase_with_patricia_aas.html).

Instead of being overwhelmed by the idea of starting to tinker with a codebase, create a local version-controlled project with the codebase in it!
E.g. fork a GitHub repo, and use `usethis::create_from_github()`.
Then install open it, install the dependencies via `remotes::install_deps(dependencies = TRUE)`, build or load it.
Before amending things, create a new branch via e.g. `gert::git_branch_create("tinkering")`.
I suppose that if I were fancy I'd say this step is your [_mise en place_](https://fortelabs.co/blog/mise-en-place-for-knowledge-workers/).

Obviously to reach that stage you'll need to know _what_ codebase is the one to be working on.
However, you'll probably start from some code in any case, e.g. your currently buggy code.

## Make your problem smaller

In case of a bug, you'll often be advised to make it a minimal reproducible example.
You'll often hear this when you try and communicate your bug to someone else, but it is great practice to do this for yourself!
An important
A reprex is both a concept (reprex for reproducible example) and a package for communicating such examples, both promoted and maintained by Jenny Bryan.
Why use reprex?

* The isolated bug is easier to solve or will be solved by creating it ! In Jenny Bryan's talk ["Object of type 'closure' is not subsettable"](https://github.com/jennybc/debugging#readme) there's an example of original code and its minified version.

* As it is run in an isolated session you can be more sure that it's reproducible.

* You can send your bug in a format ideal for experts !

How does reprex work?

* You write some code somewhere (including loading libraries, creating toy data etc.).

* You copy the code to your clipboard.

* You run `reprex::reprex()` and reprex runs your code in an isolated session!

* You get the rendered code on the clipboard (and a preview in RStudio Viewer pane)! Error messages rendered, images uploaded to imgur.

* You paste the rendered code somewhere to show to someone.

To learn more about reprex and adopt it, I'd recommend watching [the RStudio webinar about reprex](https://resources.rstudio.com/webinars/help-me-help-you-creating-reproducible-examples-jenny-bryan) and reading reprex vignettes in particular ["Reprex do's and don'ts"]](https://reprex.tidyverse.org/articles/reprex-dos-and-donts.html).


Also in the case of a bug maybe you don't need to read this post further if your problem is in the bingo below but sometimes you'll only notice obvious mistakes after making the problem smaller.

`r hugodown::embed_tweet("1354508785365078016")` 

In case of amending the features of a package, it'll be important to clearly defined the scope of what you're after.



## Pull an end / Follow the trails

As you are not going to read code from cover to cover, you'll need to find a logical way to explore the code.

I like the phrase _follow the trails_ by Kara Woo in her excellent RStudio conference talk ["Box plots A case study in debugging and perseverance"](https://www.rstudio.com/resources/rstudioconf-2019/box-plots-a-case-study-in-debugging-and-perseverance/) as well as the phrase _pull an end_ by Patricia Aas in her also excellent talk ["Reading Other People's Code"](https://patricia.no/2018/09/19/reading_other_peoples_code.html)

### Find where to start

Easy case: there's a message on screen telling you where an error occurred, or you know what function you want to amend.
Alternatively,

* You can put the error / warning in a search engine.
* If there's an unclear error you can try to see the traceback i.e. what functions were called leading to that error. In her talk ["Object of type 'closure' is not subsettable"](https://github.com/jennybc/debugging#readme), Jenny Bryan explains very well what a traceback is. In my `.Rprofile` I have

```r
options(
error = rlang::entrace, 
rlang_backtrace_on_error = "branch")
```

thanks to a [tweet by Noam Ross](https://twitter.com/noamross/status/1202269314029621251) reporting a tip by Jenny Bryan. "It gives trimmed tracebacks when using pipes."

* If there's no error but say a warning you could try to [convert the warning to an error](https://adv-r.hadley.nz/debugging.html#non-error-failures).

### Explore from that starting point

* You can use "grepping" as said by Patricia Aas: look for the occurrences of a function or variable name in a local folder, or via GitHub (advanced) search. You can limit the hits to some types of files e.g. R scripts in `R/`.
* In your IDE e.g. RStudio there might be a way to go directly to the _definition_ of function.

### How to read code: space and time

* Hopefully the code makes sense on its own.
* Sometimes using git blame or looking at the git history might help understand the context of some aspects of the code, if there's no code comment referring an issue. Do not actually _blame_ people, though. To make your git history more informative, use branches + squash and merge.


## Build your mental model of the code

That's what Patricia Aas call "mental machine".
You might want to draw some sort of diagram by hand (or programmatically).

## Beyond browsing files, `browser()`

Resources for learning proper debugging tools.

### Beyond R

Sometimes the bug or element to tweak will actively live outside of R.
Maybe in some C code you are wrapping, maybe in a CSS file.
You will therefore have to learn debugging tools for these things too!

## Read tests? Write some for sure

In Kara Woo's talk, she explained she added tests.
In Jenny Bryan's talk she uses the word "deter".

## Rubberducking to a persona

`r hugodown::embed_tweet("1409533060790558725")`

## Refactoring

Tip by Patricia Aas.
Do not actually contribute that as a first PR.

clean code contributions to codemetar.
Also https://qntm.org/clean

## Asking for help

### How

### Where

## Reading other people's debugging journeys, document yours

Sadly but understandably people will often only take the time to document their debugging journey when the bug is especially tricky or weird.
Besides, few people write actual [debugging games](https://jvns.ca/blog/2021/04/16/notes-on-debugging-puzzles/).

In the meantime, you might enjoy watching or hearing some debugging journeys.
You will notice how these programmers make and invalidate hypotheses.

* ["Box plots A case study in debugging and perseverance"](https://www.rstudio.com/resources/rstudioconf-2019/box-plots-a-case-study-in-debugging-and-perseverance/)
* https://www.jimhester.com/post/2018-03-30-debugging-journey/ reminds me of https://wizardzines.com/comics/track-your-progress/
* https://blog.r-hub.io/2020/02/20/processx-blocked-sigchld/
* https://reside-ic.github.io/blog/debugging-and-fixing-crans-additional-checks-errors/
* https://reside-ic.github.io/blog/debugging-memory-errors-with-valgrind-and-gdb/

If you end up documenting your own code detective story, please tell me, I'd like to read it!

## Conclusion

Being tired

`hugodown::embed_tweet("1385573317277532162")` 

Also non technical aspects

`hugodown::embed_tweet("1403405539971842052")`